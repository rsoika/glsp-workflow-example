"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var smodel_1 = require("../../base/model/smodel");
var mouse_tool_1 = require("../../base/views/mouse-tool");
var smodel_utils_1 = require("../../base/model/smodel-utils");
var viewport_1 = require("./viewport");
var model_1 = require("./model");
var model_2 = require("../move/model");
var model_3 = require("../routing/model");
var model_4 = require("../projection/model");
var center_fit_1 = require("./center-fit");
var browser_1 = require("../../utils/browser");
function isScrollable(element) {
    return 'scroll' in element;
}
exports.isScrollable = isScrollable;
var ScrollMouseListener = /** @class */ (function (_super) {
    __extends(ScrollMouseListener, _super);
    function ScrollMouseListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scrollbarMouseDownDelay = 200;
        return _this;
    }
    ScrollMouseListener.prototype.mouseDown = function (target, event) {
        var _this = this;
        var moveable = smodel_utils_1.findParentByFeature(target, model_2.isMoveable);
        if (moveable === undefined && !(target instanceof model_3.SRoutingHandle)) {
            var viewport = smodel_utils_1.findParentByFeature(target, model_1.isViewport);
            if (viewport) {
                this.lastScrollPosition = { x: event.pageX, y: event.pageY };
                this.scrollbar = this.getScrollbar(event);
                if (this.scrollbar) {
                    window.clearTimeout(this.scrollbarMouseDownTimeout);
                    return this.moveScrollBar(viewport, event, this.scrollbar, true)
                        .map(function (action) { return new Promise(function (resolve) {
                        _this.scrollbarMouseDownTimeout = window.setTimeout(function () { return resolve(action); }, _this.scrollbarMouseDownDelay);
                    }); });
                }
            }
            else {
                this.lastScrollPosition = undefined;
                this.scrollbar = undefined;
            }
        }
        return [];
    };
    ScrollMouseListener.prototype.mouseMove = function (target, event) {
        if (event.buttons === 0) {
            return this.mouseUp(target, event);
        }
        if (this.scrollbar) {
            window.clearTimeout(this.scrollbarMouseDownTimeout);
            var viewport = smodel_utils_1.findParentByFeature(target, model_1.isViewport);
            if (viewport) {
                return this.moveScrollBar(viewport, event, this.scrollbar);
            }
        }
        if (this.lastScrollPosition) {
            var viewport = smodel_utils_1.findParentByFeature(target, model_1.isViewport);
            if (viewport) {
                return this.dragCanvas(viewport, event, this.lastScrollPosition);
            }
        }
        return [];
    };
    ScrollMouseListener.prototype.mouseEnter = function (target, event) {
        if (target instanceof smodel_1.SModelRoot && event.buttons === 0) {
            this.mouseUp(target, event);
        }
        return [];
    };
    ScrollMouseListener.prototype.mouseUp = function (target, event) {
        this.lastScrollPosition = undefined;
        this.scrollbar = undefined;
        return [];
    };
    ScrollMouseListener.prototype.doubleClick = function (target, event) {
        var viewport = smodel_utils_1.findParentByFeature(target, model_1.isViewport);
        if (viewport) {
            var scrollbar = this.getScrollbar(event);
            if (scrollbar) {
                window.clearTimeout(this.scrollbarMouseDownTimeout);
                var targetElement = this.findClickTarget(scrollbar, event);
                var elementId = void 0;
                if (targetElement && targetElement.id.startsWith('horizontal-projection:')) {
                    elementId = targetElement.id.substring('horizontal-projection:'.length);
                }
                else if (targetElement && targetElement.id.startsWith('vertical-projection:')) {
                    elementId = targetElement.id.substring('vertical-projection:'.length);
                }
                if (elementId) {
                    return [new center_fit_1.CenterAction([elementId], true, true)];
                }
            }
        }
        return [];
    };
    ScrollMouseListener.prototype.dragCanvas = function (viewport, event, lastScrollPosition) {
        var dx = (event.pageX - lastScrollPosition.x) / viewport.zoom;
        var dy = (event.pageY - lastScrollPosition.y) / viewport.zoom;
        var newViewport = {
            scroll: {
                x: viewport.scroll.x - dx,
                y: viewport.scroll.y - dy,
            },
            zoom: viewport.zoom
        };
        this.lastScrollPosition = { x: event.pageX, y: event.pageY };
        return [new viewport_1.SetViewportAction(viewport.id, newViewport, false)];
    };
    ScrollMouseListener.prototype.moveScrollBar = function (model, event, scrollbar, animate) {
        if (animate === void 0) { animate = false; }
        var modelBounds = model_4.getModelBounds(model);
        if (!modelBounds || model.zoom <= 0) {
            return [];
        }
        var scrollbarRect = scrollbar.getBoundingClientRect();
        var newScroll;
        if (this.getScrollbarOrientation(scrollbar) === 'horizontal') {
            if (scrollbarRect.width <= 0) {
                return [];
            }
            var viewportSize = (model.canvasBounds.width / (model.zoom * modelBounds.width)) * scrollbarRect.width;
            var position = event.clientX - scrollbarRect.x - viewportSize / 2;
            if (position < 0) {
                position = 0;
            }
            else if (position > scrollbarRect.width - viewportSize) {
                position = scrollbarRect.width - viewportSize;
            }
            newScroll = {
                x: modelBounds.x + (position / scrollbarRect.width) * modelBounds.width,
                y: model.scroll.y
            };
        }
        else {
            if (scrollbarRect.height <= 0) {
                return [];
            }
            var viewportSize = (model.canvasBounds.height / (model.zoom * modelBounds.height)) * scrollbarRect.height;
            var position = event.clientY - scrollbarRect.y - viewportSize / 2;
            if (position < 0) {
                position = 0;
            }
            else if (position > scrollbarRect.height - viewportSize) {
                position = scrollbarRect.height - viewportSize;
            }
            newScroll = {
                x: model.scroll.x,
                y: modelBounds.y + (position / scrollbarRect.height) * modelBounds.height
            };
        }
        return [new viewport_1.SetViewportAction(model.id, { scroll: newScroll, zoom: model.zoom }, animate)];
    };
    ScrollMouseListener.prototype.getScrollbar = function (event) {
        var element = event.target;
        while (element) {
            if (element.classList && element.classList.contains('sprotty-projection-bar')) {
                return element;
            }
            element = element.parentElement;
        }
        return undefined;
    };
    ScrollMouseListener.prototype.getScrollbarOrientation = function (scrollbar) {
        if (scrollbar.classList.contains('horizontal')) {
            return 'horizontal';
        }
        else {
            return 'vertical';
        }
    };
    ScrollMouseListener.prototype.findClickTarget = function (scrollbar, event) {
        var matching = Array.from(scrollbar.children).filter(function (child) {
            return child.id && child.classList.contains('sprotty-projection') && browser_1.hitsMouseEvent(child, event);
        });
        if (matching.length > 0) {
            return matching[matching.length - 1];
        }
        return undefined;
    };
    return ScrollMouseListener;
}(mouse_tool_1.MouseListener));
exports.ScrollMouseListener = ScrollMouseListener;
//# sourceMappingURL=scroll.js.map