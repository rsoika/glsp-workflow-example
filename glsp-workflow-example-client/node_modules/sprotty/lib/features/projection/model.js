"use strict";
/********************************************************************************
 * Copyright (c) 2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
var smodel_1 = require("../../base/model/smodel");
var geometry_1 = require("../../utils/geometry");
var object_1 = require("../../utils/object");
var model_1 = require("../bounds/model");
function isProjectable(arg) {
    return object_1.hasOwnProperty(arg, 'projectionCssClasses');
}
exports.isProjectable = isProjectable;
/**
 * Gather all projections of elements contained in the given parent element.
 */
function getProjections(parent) {
    var result;
    for (var _i = 0, _a = parent.children; _i < _a.length; _i++) {
        var child = _a[_i];
        if (isProjectable(child) && model_1.isBoundsAware(child) && child.projectionCssClasses.length > 0) {
            var projection = {
                elementId: child.id,
                projectedBounds: getProjectedBounds(child),
                cssClasses: child.projectionCssClasses
            };
            if (result) {
                result.push(projection);
            }
            else {
                result = [projection];
            }
        }
        if (child.children.length > 0) {
            var childProj = getProjections(child);
            if (childProj) {
                if (result) {
                    result.push.apply(result, childProj);
                }
                else {
                    result = childProj;
                }
            }
        }
    }
    return result;
}
exports.getProjections = getProjections;
/**
 * Compute the projected bounds of the given model element, that is the absolute position in the diagram.
 */
function getProjectedBounds(model) {
    var bounds = model.bounds;
    var parent = model.parent;
    while (parent instanceof smodel_1.SChildElement) {
        bounds = parent.localToParent(bounds);
        parent = parent.parent;
    }
    return bounds;
}
exports.getProjectedBounds = getProjectedBounds;
var MAX_COORD = 1000000000;
/**
 * Determine the total bounds of a model; this takes the viewport into consideration
 * so it can be shown in the projections.
 */
function getModelBounds(model) {
    var minX = MAX_COORD;
    var minY = MAX_COORD;
    var maxX = -MAX_COORD;
    var maxY = -MAX_COORD;
    var bounds = model_1.isBoundsAware(model) ? model.bounds : undefined;
    if (bounds && geometry_1.isValidDimension(bounds)) {
        // Get the bounds directly from the model if it returns a valid size
        minX = bounds.x;
        minY = bounds.y;
        maxX = minX + bounds.width;
        maxY = minY + bounds.height;
    }
    else {
        // Determine the min. / max coordinates of top-level model elements
        // Note that this approach is slower, so provide valid bounds to speed up the process.
        for (var _i = 0, _a = model.children; _i < _a.length; _i++) {
            var element = _a[_i];
            if (model_1.isBoundsAware(element)) {
                var b = element.bounds;
                minX = Math.min(minX, b.x);
                minY = Math.min(minY, b.y);
                maxX = Math.max(maxX, b.x + b.width);
                maxY = Math.max(maxY, b.y + b.height);
            }
        }
    }
    // Enlarge the bounds by the current viewport to ensure it always fits into the projection
    minX = Math.min(minX, model.scroll.x);
    minY = Math.min(minY, model.scroll.y);
    maxX = Math.max(maxX, model.scroll.x + model.canvasBounds.width / model.zoom);
    maxY = Math.max(maxY, model.scroll.y + model.canvasBounds.height / model.zoom);
    if (minX < maxX && minY < maxY) {
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }
    return undefined;
}
exports.getModelBounds = getModelBounds;
//# sourceMappingURL=model.js.map