"use strict";
/********************************************************************************
 * Copyright (c) 2018-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var smodel_1 = require("../../base/model/smodel");
var types_1 = require("../../base/types");
var view_1 = require("../../base/views/view");
var registry_1 = require("../../utils/registry");
var model_1 = require("./model");
var polyline_edge_router_1 = require("./polyline-edge-router");
function isMultipleEdgesRouter(router) {
    return router.routeAll !== undefined;
}
var EdgeRouterRegistry = /** @class */ (function (_super) {
    __extends(EdgeRouterRegistry, _super);
    function EdgeRouterRegistry(edgeRouters) {
        var _this = _super.call(this) || this;
        edgeRouters.forEach(function (router) { return _this.register(router.kind, router); });
        return _this;
    }
    Object.defineProperty(EdgeRouterRegistry.prototype, "defaultKind", {
        get: function () {
            return polyline_edge_router_1.PolylineEdgeRouter.KIND;
        },
        enumerable: true,
        configurable: true
    });
    EdgeRouterRegistry.prototype.get = function (kind) {
        return _super.prototype.get.call(this, kind || this.defaultKind);
    };
    /**
     * Computes the routes of all edges contained by the specified `parent`.
     * After all routes are available, it'll apply the registered `EdgeRoutePostProcessors`.
     * @param parent the parent to traverse for edges
     * @returns the routes of all edges that are children of `parent`
     */
    EdgeRouterRegistry.prototype.routeAllChildren = function (parent) {
        var routing = this.doRouteAllChildren(parent);
        for (var _i = 0, _a = this.postProcessors; _i < _a.length; _i++) {
            var postProcessor = _a[_i];
            postProcessor.apply(routing);
        }
        return routing;
    };
    /**
     * Recursively traverses the children of `parent`, collects children grouped by router kind,
     * and then routes them either.
     * @param parent the parent to traverse for edges
     * @returns the routes of all edges that are children of `parent`
     */
    EdgeRouterRegistry.prototype.doRouteAllChildren = function (parent) {
        var _this = this;
        var routing = new EdgeRouting();
        var routersEdges = new Map();
        var elementsToProcess = [parent];
        while (elementsToProcess.length > 0) {
            var element = elementsToProcess.shift();
            for (var _i = 0, _a = element.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child instanceof model_1.SRoutableElement) {
                    var routerKind = child.routerKind || this.defaultKind;
                    if (routersEdges.has(routerKind)) {
                        routersEdges.get(routerKind).push(child);
                    }
                    else {
                        routersEdges.set(routerKind, [child]);
                    }
                }
                if (child instanceof smodel_1.SParentElement) {
                    elementsToProcess.push(child);
                }
            }
        }
        routersEdges.forEach(function (edges, routerKind) {
            var childRouter = _this.get(routerKind);
            if (isMultipleEdgesRouter(childRouter)) {
                routing.setAll(childRouter.routeAll(edges, parent));
            }
            else {
                for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {
                    var edge = edges_1[_i];
                    routing.set(edge.id, _this.route(edge));
                }
            }
        });
        return routing;
    };
    /**
     * Computes or obtains the route of a single edge.
     * @param edge the edge to be routed
     * @param args arguments that may contain an `EdgeRouting` already
     * @returns the route of the specified `edge`
     */
    EdgeRouterRegistry.prototype.route = function (edge, args) {
        var edgeRouting = view_1.findArgValue(args, 'edgeRouting');
        if (edgeRouting) {
            var route = edgeRouting.get(edge.id);
            if (route) {
                return route;
            }
        }
        var router = this.get(edge.routerKind);
        return router.route(edge);
    };
    __decorate([
        inversify_1.multiInject(types_1.TYPES.IEdgeRoutePostprocessor), inversify_1.optional(),
        __metadata("design:type", Array)
    ], EdgeRouterRegistry.prototype, "postProcessors", void 0);
    EdgeRouterRegistry = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.multiInject(types_1.TYPES.IEdgeRouter)),
        __metadata("design:paramtypes", [Array])
    ], EdgeRouterRegistry);
    return EdgeRouterRegistry;
}(registry_1.InstanceRegistry));
exports.EdgeRouterRegistry = EdgeRouterRegistry;
/**
 * Map of edges and their computed routes.
 */
var EdgeRouting = /** @class */ (function () {
    function EdgeRouting() {
        this.routesMap = new Map();
    }
    EdgeRouting.prototype.set = function (routableId, route) {
        this.routesMap.set(routableId, route);
    };
    EdgeRouting.prototype.setAll = function (otherRoutes) {
        var _this = this;
        otherRoutes.routes.forEach(function (route, routableId) { return _this.set(routableId, route); });
    };
    EdgeRouting.prototype.get = function (routableId) {
        return this.routesMap.get(routableId);
    };
    Object.defineProperty(EdgeRouting.prototype, "routes", {
        get: function () {
            return this.routesMap;
        },
        enumerable: true,
        configurable: true
    });
    return EdgeRouting;
}());
exports.EdgeRouting = EdgeRouting;
//# sourceMappingURL=routing.js.map