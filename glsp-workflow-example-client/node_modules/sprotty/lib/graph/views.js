"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @jsx svg */
var inversify_1 = require("inversify");
var smodel_utils_1 = require("../base/model/smodel-utils");
var vnode_utils_1 = require("../base/views/vnode-utils");
var views_1 = require("../features/bounds/views");
var intersection_finder_1 = require("../features/edge-intersection/intersection-finder");
var model_1 = require("../features/edge-layout/model");
var model_2 = require("../features/routing/model");
var routing_1 = require("../features/routing/routing");
var views_2 = require("../features/routing/views");
var jsx_1 = require("../lib/jsx");
var geometry_1 = require("../utils/geometry");
/**
 * IView component that turns an SGraph element and its children into a tree of virtual DOM elements.
 */
var SGraphView = /** @class */ (function () {
    function SGraphView() {
    }
    SGraphView.prototype.render = function (model, context, args) {
        var edgeRouting = this.edgeRouterRegistry.routeAllChildren(model);
        var transform = "scale(" + model.zoom + ") translate(" + -model.scroll.x + "," + -model.scroll.y + ")";
        return jsx_1.svg("svg", { "class-sprotty-graph": true },
            jsx_1.svg("g", { transform: transform }, context.renderChildren(model, { edgeRouting: edgeRouting })));
    };
    __decorate([
        inversify_1.inject(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
    ], SGraphView.prototype, "edgeRouterRegistry", void 0);
    SGraphView = __decorate([
        inversify_1.injectable()
    ], SGraphView);
    return SGraphView;
}());
exports.SGraphView = SGraphView;
var PolylineEdgeView = /** @class */ (function (_super) {
    __extends(PolylineEdgeView, _super);
    function PolylineEdgeView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PolylineEdgeView.prototype.render = function (edge, context, args) {
        var route = this.edgeRouterRegistry.route(edge, args);
        if (route.length === 0) {
            return this.renderDanglingEdge("Cannot compute route", edge, context);
        }
        if (!this.isVisible(edge, route, context)) {
            if (edge.children.length === 0) {
                return undefined;
            }
            // The children of an edge are not necessarily inside the bounding box of the route,
            // so we need to render a group to ensure the children have a chance to be rendered.
            return jsx_1.svg("g", null, context.renderChildren(edge, { route: route }));
        }
        return jsx_1.svg("g", { "class-sprotty-edge": true, "class-mouseover": edge.hoverFeedback },
            this.renderLine(edge, route, context, args),
            this.renderAdditionals(edge, route, context),
            context.renderChildren(edge, { route: route }));
    };
    PolylineEdgeView.prototype.renderLine = function (edge, segments, context, args) {
        var firstPoint = segments[0];
        var path = "M " + firstPoint.x + "," + firstPoint.y;
        for (var i = 1; i < segments.length; i++) {
            var p = segments[i];
            path += " L " + p.x + "," + p.y;
        }
        return jsx_1.svg("path", { d: path });
    };
    PolylineEdgeView.prototype.renderAdditionals = function (edge, segments, context) {
        return [];
    };
    PolylineEdgeView.prototype.renderDanglingEdge = function (message, edge, context) {
        return jsx_1.svg("text", { "class-sprotty-edge-dangling": true, title: message }, "?");
    };
    __decorate([
        inversify_1.inject(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
    ], PolylineEdgeView.prototype, "edgeRouterRegistry", void 0);
    PolylineEdgeView = __decorate([
        inversify_1.injectable()
    ], PolylineEdgeView);
    return PolylineEdgeView;
}(views_2.RoutableView));
exports.PolylineEdgeView = PolylineEdgeView;
/**
 * A `PolylineEdgeView` that renders jumps over intersections.
 *
 * In order to find intersections, `IntersectionFinder` needs to be configured as a `TYPES.IEdgeRoutePostprocessor`
 * so that that intersections are declared as `IntersectingRoutedPoint` in the computed routes.
 *
 * @see IntersectionFinder
 * @see IntersectingRoutedPoint
 * @see EdgeRouterRegistry
 */
var JumpingPolylineEdgeView = /** @class */ (function (_super) {
    __extends(JumpingPolylineEdgeView, _super);
    function JumpingPolylineEdgeView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.jumpOffsetBefore = 5;
        _this.jumpOffsetAfter = 5;
        _this.skipOffsetBefore = 3;
        _this.skipOffsetAfter = 2;
        return _this;
    }
    JumpingPolylineEdgeView.prototype.renderLine = function (edge, segments, context, args) {
        var path = '';
        for (var i = 0; i < segments.length; i++) {
            var p = segments[i];
            if (i === 0) {
                path = "M " + p.x + "," + p.y;
            }
            if (intersection_finder_1.isIntersectingRoutedPoint(p)) {
                path += this.intersectionPath(edge, segments, p, args);
            }
            if (i !== 0) {
                path += " L " + p.x + "," + p.y;
            }
        }
        return jsx_1.svg("path", { d: path });
    };
    JumpingPolylineEdgeView.prototype.intersectionPath = function (edge, segments, intersectingPoint, args) {
        var path = '';
        for (var _i = 0, _a = intersectingPoint.intersections.sort(intersection_finder_1.BY_X_THEN_Y); _i < _a.length; _i++) {
            var intersection = _a[_i];
            var otherLineSegment = this.getOtherLineSegment(edge, intersection, args);
            if (otherLineSegment === undefined) {
                continue;
            }
            var lineSegment = this.getLineSegment(edge, intersection, args, segments);
            var intersectionPoint = intersection.intersectionPoint;
            if (Math.abs(lineSegment.slopeOrMax) < Math.abs(otherLineSegment.slopeOrMax)) {
                path += this.createJumpPath(intersectionPoint, lineSegment);
            }
            else {
                path += this.createSkipPath(intersectionPoint, lineSegment);
            }
        }
        return path;
    };
    JumpingPolylineEdgeView.prototype.getOtherLineSegment = function (currentEdge, intersection, args) {
        var otherEdgeId = intersection.routable1 === currentEdge.id ? intersection.routable2 : intersection.routable1;
        var otherEdge = currentEdge.index.getById(otherEdgeId);
        if (!(otherEdge instanceof model_2.SRoutableElement)) {
            return undefined;
        }
        return this.getLineSegment(otherEdge, intersection, args);
    };
    JumpingPolylineEdgeView.prototype.getLineSegment = function (edge, intersection, args, segments) {
        var route = segments ? segments : this.edgeRouterRegistry.route(edge, args);
        var index = intersection.routable1 === edge.id ? intersection.segmentIndex1 : intersection.segmentIndex2;
        return new geometry_1.PointToPointLine(route[index], route[index + 1]);
    };
    JumpingPolylineEdgeView.prototype.createJumpPath = function (intersectionPoint, lineSegment) {
        var anchorBefore = geometry_1.shiftTowards(intersectionPoint, lineSegment.p1, this.jumpOffsetBefore);
        var anchorAfter = geometry_1.shiftTowards(intersectionPoint, lineSegment.p2, this.jumpOffsetAfter);
        var rotation = lineSegment.p1.x < lineSegment.p2.x ? 1 : 0;
        return " L " + anchorBefore.x + "," + anchorBefore.y + " A 1,1 0,0 " + rotation + " " + anchorAfter.x + "," + anchorAfter.y;
    };
    JumpingPolylineEdgeView.prototype.createSkipPath = function (intersectionPoint, lineSegment) {
        var offsetBefore;
        var offsetAfter;
        if (intersectionPoint.y < lineSegment.p1.y) {
            offsetBefore = -this.skipOffsetBefore;
            offsetAfter = this.jumpOffsetAfter + this.skipOffsetAfter;
        }
        else {
            offsetBefore = this.jumpOffsetBefore + this.skipOffsetAfter;
            offsetAfter = -this.skipOffsetBefore;
        }
        var anchorBefore = geometry_1.shiftTowards(intersectionPoint, lineSegment.p1, offsetBefore);
        var anchorAfter = geometry_1.shiftTowards(intersectionPoint, lineSegment.p2, offsetAfter);
        return " L " + anchorBefore.x + "," + anchorBefore.y + " M " + anchorAfter.x + "," + anchorAfter.y;
    };
    JumpingPolylineEdgeView = __decorate([
        inversify_1.injectable()
    ], JumpingPolylineEdgeView);
    return JumpingPolylineEdgeView;
}(PolylineEdgeView));
exports.JumpingPolylineEdgeView = JumpingPolylineEdgeView;
/**
 * A `PolylineEdgeView` that renders gaps on intersections.
 *
 * In order to find intersections, `IntersectionFinder` needs to be configured as a `TYPES.IEdgeRoutePostprocessor`
 * so that that intersections are declared as `IntersectingRoutedPoint` in the computed routes.
 *
 * @see IntersectionFinder
 * @see IntersectingRoutedPoint
 * @see EdgeRouterRegistry
 */
var PolylineEdgeViewWithGapsOnIntersections = /** @class */ (function (_super) {
    __extends(PolylineEdgeViewWithGapsOnIntersections, _super);
    function PolylineEdgeViewWithGapsOnIntersections() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.skipOffsetBefore = 3;
        _this.skipOffsetAfter = 3;
        return _this;
    }
    PolylineEdgeViewWithGapsOnIntersections.prototype.createJumpPath = function (intersectionPoint, lineSegment) {
        return "";
    };
    PolylineEdgeViewWithGapsOnIntersections.prototype.createSkipPath = function (intersectionPoint, lineSegment) {
        var anchorBefore = geometry_1.shiftTowards(intersectionPoint, lineSegment.p1, this.skipOffsetBefore);
        var anchorAfter = geometry_1.shiftTowards(intersectionPoint, lineSegment.p2, this.skipOffsetAfter);
        return " L " + anchorBefore.x + "," + anchorBefore.y + " M " + anchorAfter.x + "," + anchorAfter.y;
    };
    PolylineEdgeViewWithGapsOnIntersections = __decorate([
        inversify_1.injectable()
    ], PolylineEdgeViewWithGapsOnIntersections);
    return PolylineEdgeViewWithGapsOnIntersections;
}(JumpingPolylineEdgeView));
exports.PolylineEdgeViewWithGapsOnIntersections = PolylineEdgeViewWithGapsOnIntersections;
var SRoutingHandleView = /** @class */ (function () {
    function SRoutingHandleView() {
        this.minimalPointDistance = 10;
    }
    SRoutingHandleView.prototype.render = function (handle, context, args) {
        if (args && args.route) {
            if (handle.parent instanceof model_2.SRoutableElement) {
                var router = this.edgeRouterRegistry.get(handle.parent.routerKind);
                var theRoute = args.route === undefined ? this.edgeRouterRegistry.route(handle.parent, args) : args.route;
                var position = router.getHandlePosition(handle.parent, theRoute, handle);
                if (position !== undefined) {
                    var node = jsx_1.svg("circle", { "class-sprotty-routing-handle": true, "class-selected": handle.selected, "class-mouseover": handle.hoverFeedback, cx: position.x, cy: position.y, r: this.getRadius() });
                    vnode_utils_1.setAttr(node, 'data-kind', handle.kind);
                    return node;
                }
            }
        }
        // Fallback: Create an empty group
        return jsx_1.svg("g", null);
    };
    SRoutingHandleView.prototype.getRadius = function () {
        return 7;
    };
    __decorate([
        inversify_1.inject(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
    ], SRoutingHandleView.prototype, "edgeRouterRegistry", void 0);
    SRoutingHandleView = __decorate([
        inversify_1.injectable()
    ], SRoutingHandleView);
    return SRoutingHandleView;
}());
exports.SRoutingHandleView = SRoutingHandleView;
var SLabelView = /** @class */ (function (_super) {
    __extends(SLabelView, _super);
    function SLabelView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SLabelView.prototype.render = function (label, context) {
        if (!model_1.isEdgeLayoutable(label) && !this.isVisible(label, context)) {
            return undefined;
        }
        var vnode = jsx_1.svg("text", { "class-sprotty-label": true }, label.text);
        var subType = smodel_utils_1.getSubType(label);
        if (subType) {
            vnode_utils_1.setAttr(vnode, 'class', subType);
        }
        return vnode;
    };
    SLabelView = __decorate([
        inversify_1.injectable()
    ], SLabelView);
    return SLabelView;
}(views_1.ShapeView));
exports.SLabelView = SLabelView;
var SCompartmentView = /** @class */ (function () {
    function SCompartmentView() {
    }
    SCompartmentView.prototype.render = function (compartment, context, args) {
        var translate = "translate(" + compartment.bounds.x + ", " + compartment.bounds.y + ")";
        var vnode = jsx_1.svg("g", { transform: translate, "class-sprotty-comp": "{true}" }, context.renderChildren(compartment));
        var subType = smodel_utils_1.getSubType(compartment);
        if (subType)
            vnode_utils_1.setAttr(vnode, 'class', subType);
        return vnode;
    };
    SCompartmentView = __decorate([
        inversify_1.injectable()
    ], SCompartmentView);
    return SCompartmentView;
}());
exports.SCompartmentView = SCompartmentView;
//# sourceMappingURL=views.js.map